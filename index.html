<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree | Holiday Magic</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap"
        rel="stylesheet">
    <!-- Force HTTPS (Required for Camera Access) -->
    <script>
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            location.replace(`https:${location.href.substring(location.protocol.length)}`);
        }
    </script>

    <style>
        :root {
            --color-bg: #000000;
            --color-gold: #d4af37;
            --color-cream: #fceea7;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--color-bg);
            font-family: 'Times New Roman', serif;
            color: var(--color-gold);
            user-select: none;
        }

        /* UI Styles */
        h1 {
            font-family: 'Cinzel', serif;
            font-size: 56px;
            text-align: center;
            position: absolute;
            top: 20px;
            width: 100%;
            margin: 0;
            z-index: 10;
            background: linear-gradient(to bottom, #ffffff, var(--color-gold));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            pointer-events: none;
        }



        /* Loader */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(212, 175, 55, 0.1);
            border-top: 3px solid var(--color-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loader-text {
            font-family: 'Cinzel', serif;
            color: var(--color-gold);
            letter-spacing: 4px;
            font-size: 14px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }



        /* Hidden Webcam Container */
        .webcam-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            opacity: 0;
            /* Invisible as requested */
            pointer-events: none;
            overflow: hidden;
        }



        .top-right-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
        }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
    <!-- Dependencies for MetingJS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script>

</head>

<body>

    <!-- Loader -->
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">LOADING HOLIDAY MAGIC</div>
    </div>



    <!-- NetEase Cloud Music Iframe -->
    <!-- MetingJS (Powered by APlayer) -->
    <meting-js name="Christmas Star" artist="Jay Chou" url="music/JayChou-Chrismas_Star.mp3"
        cover="https://cdn-icons-png.flaticon.com/512/614/614105.png" fixed="true" autoplay="true" theme="#d4af37">
    </meting-js>

    <!-- UI -->
    <h1>Merry Christmas</h1>





    <!-- Hidden Webcam -->
    <div class="webcam-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="cv-canvas"></canvas>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm';

        // ERROR TRAPPING
        // ERROR TRAPPING
        // window.onerror = function (msg, url, line, col, error) {
        //     console.error("Global Error:", msg, line);
        //     // alert("Error: " + msg + "\nLine: " + line); // Disable for production
        //     return false;
        // };

        // --- Configuration ---
        const CONFIG = {
            colors: {
                green: 0x0f5d26,  // Forest Green
                red: 0xae0e0e,    // Classic Red
                gold: 0xd4af37,
                white: 0xffffff,
                bg: 0x000000,
                orange: 0xffa500,
                blue: 0x4169e1
            },
            particles: {
                mainCount: 2000,
                dustCount: 4000,
                scatterRadius: 20
            },

            // textPhotoContent: "JOYEUX NOEL", // Deprecated
            cardMessages: [
                "Merry Christmas",
                "Joy to the World",
                "Love & Peace\nYa",
                "å¤©å¤©é–‹å¿ƒ"
            ],
            gestures: { palmOpenThreshold: 0.35, sensitivity: 6.0 }
        };

        // --- CUSTOM ASSETS FOR GITHUB PAGES ---
        // IMPORTANT: Web pages CANNOT scan your folders automatically.
        // You MUST explicitly list every file name you want to load below.
        const CUSTOM_ASSETS = {
            // 1. Photos: Put them in a folder (e.g. 'photos/') and list filenames here
            // Example: ['photos/pic1.jpg', 'photos/pic2.png']
            photos: [
                'photos/xmas.jpeg'
                // 'photos/2.jpg'
            ],


        };

        // --- Global State ---
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            targetPhoto: null,
            potentialTarget: null, // New: Closest photo (Shadow Target)
            forceTextTarget: false, // New flag for OK gesture
            time: 0,
            rotation: { x: 0, y: 0 },
            mouse: new THREE.Vector2(),
            // Advanced Gesture State
            scatterScale: 1.0,
            gestureBaseSpread: null,
            palmCenter: { x: 0.5, y: 0.5 },
            hasPalmCenter: false,
            spinVel: { x: 0, y: 0 },
            isPinching: false, // Debounce flag
            lastPinchTime: 0,
            // Love Mode State
            loveSeq: {
                galleryIndex: 0,
                timer: 0,
                photos: []
            },
            // Finger Heart Debounce
            isHeartDebounce: false,
            lastHeartTime: 0
        };

        // --- Main App Logic ---
        class App {
            constructor() {
                this.initScene();
                this.initPostProcessing();
                this.initLights();
                this.initContent();
                this.initEvents();
                this.initStaticAssets(); // New: Load custom assets
                this.initMediaPipe();
                this.animate();

                // SAFETY: Force hide loader after 5 seconds if MediaPipe stalls/hangs
                setTimeout(() => {
                    if (this.hideLoader) this.hideLoader();
                    else {
                        const l = document.getElementById('loader');
                        if (l) { l.style.opacity = 0; setTimeout(() => l.style.display = 'none', 800); }
                    }
                }, 5000);
            }

            // New Buffer Method
            initStaticAssets() {
                // 1. Load Photos
                if (CUSTOM_ASSETS.photos && CUSTOM_ASSETS.photos.length > 0) {
                    const loader = new THREE.TextureLoader();
                    CUSTOM_ASSETS.photos.forEach(path => {
                        loader.load(path, (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            this.addPhotoToScene(texture);
                            console.log("Loaded custom photo:", path);
                        }, undefined, (err) => {
                            console.warn("Failed to load photo:", path);
                        });
                    });
                }


            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 2, 50);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 2.3; // Restored High Exposure
                document.body.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;

                // Environment
                const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                pmremGenerator.compileEquirectangularShader();
                const roomEnvironment = new RoomEnvironment();
                this.scene.environment = pmremGenerator.fromScene(roomEnvironment).texture;
                roomEnvironment.dispose();

                // Group for rotating all particles
                this.mainGroup = new THREE.Group();
                this.mainGroup.visible = true; // Force visible on startup
                this.scene.add(this.mainGroup);
            }

            initPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    0.5, // Restored Bloom
                    0.5,
                    0.9 // Threshold 0.9 (Standard White 1.0 will NOT bloom if dimmed)
                );

                this.composer.addPass(bloomPass);

                const outputPass = new OutputPass();
                this.composer.addPass(outputPass);

            }

            initLights() {
                // Ambient
                const ambient = new THREE.AmbientLight(0xffffff, 0.6); // Restored Ambient
                this.scene.add(ambient);

                // Internal Point (Warm)
                const point = new THREE.PointLight(CONFIG.colors.orange, 2, 50);
                point.position.set(0, 5, 0);
                this.scene.add(point);

                // Spotlights
                const spotGold = new THREE.SpotLight(CONFIG.colors.gold, 1200);
                spotGold.position.set(30, 40, 40);
                spotGold.angle = Math.PI / 6;
                spotGold.penumbra = 1;
                this.scene.add(spotGold);

                const spotBlue = new THREE.SpotLight(CONFIG.colors.blue, 600);
                spotBlue.position.set(-30, 20, -30);
                spotBlue.angle = Math.PI / 6;
                spotBlue.penumbra = 1;
                this.scene.add(spotBlue);
            }

            initContent() {
                this.particles = [];

                // Materials - Classic Red/Green Theme
                const matGreen = new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.green,
                    roughness: 0.3,
                    metalness: 0.2,
                    emissive: 0x002200, // Added emissive
                    emissiveIntensity: 0.5 // Subtle glow for foliage
                });
                const matRed = new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.red,
                    roughness: 0.2,
                    metalness: 0.6,
                    emissive: 0x330000,
                    emissiveIntensity: 3.0 // Boost for Exposure 1.0
                });
                const matGold = new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.gold,
                    roughness: 0.1,
                    metalness: 1.0,
                    emissive: 0x221100,
                    emissiveIntensity: 3.0 // Boost for Exposure 1.0
                });
                const matWhite = new THREE.MeshPhysicalMaterial({
                    color: CONFIG.colors.white,
                    roughness: 0.1,
                    metalness: 0.1,
                    clearcoat: 1.0,
                    emissive: 0xaaaaaa, // Add emissive to white ornaments
                    emissiveIntensity: 2.0
                });

                // Geometries
                const geoBox = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const geoSphere = new THREE.SphereGeometry(0.25, 32, 32);
                const geoGem = new THREE.OctahedronGeometry(0.3);

                // --- Candy Cane Generation ---
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, -0.5, 0),
                    new THREE.Vector3(0, 0.5, 0),
                    new THREE.Vector3(0.2, 0.7, 0),
                    new THREE.Vector3(0.4, 0.5, 0)
                ]);
                const caneGeo = new THREE.TubeGeometry(curve, 20, 0.1, 8, false);
                const caneCanvas = document.createElement('canvas');
                caneCanvas.width = 128;
                caneCanvas.height = 128;
                const ctx = caneCanvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 128, 128);
                // Red stripes
                ctx.fillStyle = '#ae0e0e';
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * 20);
                    ctx.lineTo(128, i * 20 + 20);
                    ctx.lineTo(128, i * 20 + 40);
                    ctx.lineTo(0, i * 20 + 20);
                    ctx.fill();
                }
                const caneTex = new THREE.CanvasTexture(caneCanvas);
                const matCane = new THREE.MeshStandardMaterial({
                    map: caneTex,
                    roughness: 0.2,
                    metalness: 0.1,
                    emissive: 0x222222, // Added emissive to candy cane
                    emissiveIntensity: 1.0
                });

                // --- Create Particles ---
                for (let i = 0; i < CONFIG.particles.mainCount; i++) {
                    let mesh;
                    let type = Math.random();

                    // Classic Distribution
                    if (type < 0.6) {
                        // Main Green Tree Foliage (Cubes)
                        mesh = new THREE.Mesh(geoBox, matGreen);
                    } else if (type < 0.8) {
                        // Red Ornaments/Apples
                        mesh = new THREE.Mesh(geoSphere, matRed);
                    } else if (type < 0.9) {
                        // Gold/White Decorations (Spheres/Gems)
                        mesh = new THREE.Mesh(
                            Math.random() > 0.5 ? geoGem : geoSphere,
                            Math.random() > 0.5 ? matGold : matWhite
                        );
                    } else {
                        // Candy Cane
                        mesh = new THREE.Mesh(caneGeo, matCane);
                        mesh.scale.set(0.5, 0.5, 0.5);
                    }

                    const particle = new Particle(mesh);
                    this.particles.push(particle);
                    this.mainGroup.add(mesh);
                }

                // --- Dust Particles (Snow) ---
                const dustGeo = new THREE.BufferGeometry();
                const dustPos = [];
                for (let i = 0; i < CONFIG.particles.dustCount; i++) {
                    const r = 25 * Math.cbrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    dustPos.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                }
                dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
                const dustMat = new THREE.PointsMaterial({
                    color: CONFIG.colors.white,
                    size: 0.08,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                const dustSystem = new THREE.Points(dustGeo, dustMat);
                this.scene.add(dustSystem);

                // --- Default Photo (Scattered) ---
                // --- Text Cards (From Config) ---
                if (CONFIG.cardMessages && CONFIG.cardMessages.length > 0) {
                    CONFIG.cardMessages.forEach(msg => {
                        this.addTextPhoto(msg);
                    });
                } else {
                    // Fallback
                    this.addTextPhoto("Merry Christmas");
                }

                this.createTopStar();

                // --- Love Mode Independent System ---
                this.loveGroup = new THREE.Group();
                this.loveGroup.visible = false;
                this.scene.add(this.loveGroup);
                this.loveParticles = [];
                this.createLoveParticles();
            }

            createLoveParticles() {
                // Classic Red & Green Palette
                const colors = {
                    red: new THREE.Color('#ae0e0e'),
                    green: new THREE.Color('#0f5d26'),
                    gold: new THREE.Color('#d4af37'),
                    white: new THREE.Color('#ffffff')
                };

                const geoms = [
                    new THREE.BoxGeometry(0.4, 0.4, 0.4), // Leaf
                    new THREE.SphereGeometry(0.25, 8, 8), // Ornament
                    new THREE.OctahedronGeometry(0.3),    // Gem
                    new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8) // Candy Cane segment
                ];

                const mats = {
                    green: new THREE.MeshStandardMaterial({ color: colors.green, roughness: 0.3 }),
                    red: new THREE.MeshStandardMaterial({ color: colors.red, roughness: 0.2, metalness: 0.1 }),
                    gold: new THREE.MeshStandardMaterial({ color: colors.gold, roughness: 0.1, metalness: 0.8, emissive: new THREE.Color(0x332200) }),
                    white: new THREE.MeshStandardMaterial({ color: colors.white, roughness: 0.9 })
                };

                // 1. Main Particles (2000)
                for (let i = 0; i < 2000; i++) {
                    let mesh, type;
                    const r = Math.random();

                    if (r < 0.4) { // 40% Green Leaves
                        mesh = new THREE.Mesh(geoms[0], mats.green);
                        type = 'LEAF';
                    } else if (r < 0.7) { // 30% Red Ornaments
                        mesh = new THREE.Mesh(geoms[1], mats.red);
                        type = 'ORNAMENT';
                    } else if (r < 0.85) { // 15% Gold Gems
                        mesh = new THREE.Mesh(geoms[2], mats.gold);
                        type = 'GEM';
                    } else { // 15% Candy
                        type = 'CANDY';
                        // Simple Red/White random assignment for 'stripes' simulation
                        mesh = new THREE.Mesh(geoms[3], Math.random() > 0.5 ? mats.white : mats.red);
                    }

                    // Initial random scatter position (hidden)
                    mesh.position.set(0, -900, 0);
                    this.loveGroup.add(mesh);

                    this.loveParticles.push({
                        mesh: mesh,
                        type: type,
                        targetPos: new THREE.Vector3(),
                        targetRot: new THREE.Euler(),
                        targetScale: new THREE.Vector3(1, 1, 1),
                        randomOffset: Math.random(),
                        // Pre-calculate random spherical coords for decoration
                        sphere: {
                            r: 50 + Math.random() * 50,
                            phi: Math.acos(-1 + (2 * Math.random())),
                            theta: Math.random() * Math.PI * 2
                        }
                    });
                }

                // 2. Dust/Snow Particles (4000)
                const dustGeom = new THREE.BufferGeometry();
                const positions = new Float32Array(4000 * 3);
                for (let i = 0; i < 4000 * 3; i++) positions[i] = (Math.random() - 0.5) * 200;
                dustGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const dustMat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.2,
                    transparent: true,
                    opacity: 0.6
                });

                this.loveDust = new THREE.Points(dustGeom, dustMat);
                this.loveGroup.add(this.loveDust);

                // Store dust data for animation
                this.dustData = [];
                for (let i = 0; i < 4000; i++) {
                    this.dustData.push({
                        x: positions[i * 3],
                        y: positions[i * 3 + 1],
                        z: positions[i * 3 + 2],
                        vy: -Math.random() * 0.2 - 0.05 // Falling snow
                    });
                }
            }

            createTopStar() {
                // --- Procedural Glitter Texture ---
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#808080'; // mid-grey base
                ctx.fillRect(0, 0, 128, 128);
                // Add noise
                for (let i = 0; i < 4000; i++) {
                    const x = Math.random() * 128;
                    const y = Math.random() * 128;
                    const v = Math.random() * 255; // random bright/dark
                    ctx.fillStyle = `rgb(${v},${v},${v})`;
                    ctx.fillRect(x, y, 2, 2);
                }
                const bumpTex = new THREE.CanvasTexture(canvas);
                bumpTex.wrapS = THREE.RepeatWrapping;
                bumpTex.wrapT = THREE.RepeatWrapping;
                bumpTex.repeat.set(2, 2);

                // --- 3D Faceted Star Geometry ---
                const outerRadius = 1.5;
                const innerRadius = 0.6;
                const thickness = 1.0;   // Increased thickness for volume
                const points = 5;

                const starGeo = new THREE.BufferGeometry();
                const vertices = [];
                const uv = []; // UVs for texture
                const indices = [];

                // 0: Front Center (UV 0.5, 0.5)
                vertices.push(0, 0, thickness);
                uv.push(0.5, 0.5);
                // 1: Back Center
                vertices.push(0, 0, -thickness);
                uv.push(0.5, 0.5);

                // Ring points
                for (let i = 0; i < points * 2; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const a = (i / (points * 2)) * Math.PI * 2;
                    const x = Math.cos(a + Math.PI / 2) * r;
                    const y = Math.sin(a + Math.PI / 2) * r;
                    vertices.push(x, y, 0);

                    // Simple radial mapping
                    uv.push(
                        0.5 + Math.cos(a + Math.PI / 2) * 0.5,
                        0.5 + Math.sin(a + Math.PI / 2) * 0.5
                    );
                }

                // Faces
                const ringStart = 2;
                const ringCount = points * 2;

                for (let i = 0; i < ringCount; i++) {
                    const current = ringStart + i;
                    const next = ringStart + ((i + 1) % ringCount);

                    // Front Face
                    indices.push(0, current, next);
                    // Back Face
                    indices.push(1, next, current);
                }

                starGeo.setIndex(indices);
                starGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                starGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));
                starGeo.computeVertexNormals();

                const mat = new THREE.MeshStandardMaterial({
                    color: 0xffd700,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5,
                    roughness: 0.3, // bump map needs some roughness surface to interact nicely
                    metalness: 1.0,
                    bumpMap: bumpTex,
                    bumpScale: 0.2, // "Concave/Convex" feeling
                    flatShading: true
                });
                const star = new THREE.Mesh(starGeo, mat);
                star.position.set(0, 13, 0);

                this.mainGroup.add(star);

                // Add a point light to the star
                const light = new THREE.PointLight(0xffd700, 3, 20);
                light.position.set(0, 13, 0);
                this.mainGroup.add(light);
            }


            addTextPhoto(text) {
                // Card Aspect Ratio: 5:7 (e.g. 500x700)
                const width = 500;
                const height = 700;
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                // 1. Background (Cream/Parchment)
                ctx.fillStyle = '#FDF5E6';
                ctx.fillRect(0, 0, width, height);

                // 2. Texture/Noise (Subtle)
                // ctx.globalAlpha = 0.05;
                // ctx.fillStyle = '#000';
                // for(let i=0; i<1000; i++) ctx.fillRect(Math.random()*width, Math.random()*height, 2, 2);
                // ctx.globalAlpha = 1.0;

                // 3. Border (Gold Double Line)
                ctx.strokeStyle = '#D4AF37';
                ctx.lineWidth = 15;
                ctx.strokeRect(20, 20, width - 40, height - 40);

                ctx.lineWidth = 4;
                ctx.strokeRect(35, 35, width - 70, height - 70);

                // 4. Text
                ctx.fillStyle = '#8B0000'; // Dark Red
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Handle Manual Line Breaks (\n)
                const lines = text.split('\n');

                if (lines.length > 1) {
                    // Multi-line support
                    const lineHeight = 100; // Vertical spacing
                    const totalHeight = (lines.length - 1) * lineHeight;
                    const startY = (height / 2) - (totalHeight / 2);

                    lines.forEach((line, index) => {
                        // Adjust font size slightly for multiline
                        const fontSize = line.length > 10 ? 60 : 80;
                        ctx.font = `bold ${fontSize}px "Cinzel", serif`;
                        ctx.fillText(line, width / 2, startY + (index * lineHeight));
                    });

                } else {
                    // Single line (Legacy auto-wrap or simple center)
                    const words = text.split(' ');
                    // Simple auto-wrap for long sentences without \n
                    if (words.length > 2 && text.length > 15) {
                        // Auto-split logic for long sentences without \n
                        const mid = Math.ceil(words.length / 2);
                        const line1 = words.slice(0, mid).join(' ');
                        const line2 = words.slice(mid).join(' ');

                        ctx.font = `bold 60px "Cinzel", serif`;
                        ctx.fillText(line1, width / 2, height / 2 - 40);
                        ctx.fillText(line2, width / 2, height / 2 + 40);
                    } else {
                        // Standard single line
                        const fontSize = text.length > 10 ? 60 : 80;
                        ctx.font = `bold ${fontSize}px "Cinzel", serif`;
                        ctx.fillText(text, width / 2, height / 2);
                    }
                }

                // Decorative Corner (Simple Circle)
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath(); ctx.arc(width / 2, 80, 10, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(width / 2, height - 80, 10, 0, Math.PI * 2); ctx.fill();

                const texture = new THREE.CanvasTexture(canvas);
                texture.colorSpace = THREE.SRGBColorSpace;

                // Add to scene with specific dimensions (0.5 x 0.7)
                this.addPhotoToScene(texture, true, 0.5, 0.7);
            }

            addPhotoToScene(texture, isDefault = false, width = 0.6, height = 0.6) {
                const geo = new THREE.BoxGeometry(width, height, 0.05);
                // Fix Glare: Use BasicMaterial (Unlit) + Disable Tone Mapping
                // Use grey color (0.86) to stay below Bloom Threshold (0.9)
                const mat = new THREE.MeshBasicMaterial({
                    map: texture,
                    color: 0xdddddd,
                    toneMapped: false
                });
                const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.8 });
                const mesh = new THREE.Mesh(geo, [frameMat, frameMat, frameMat, frameMat, mat, mat]); // Front/Back are index 4/5

                const particle = new Particle(mesh, 'PHOTO');
                particle.isDefault = isDefault;
                this.particles.push(particle);
                this.mainGroup.add(mesh);
            }

            pickNextTarget() {
                // Sequential Selection: Text Photo -> Upload 1 -> Upload 2 -> ... -> Loop
                const allPhotos = this.particles.filter(p => p.type === 'PHOTO');
                if (allPhotos.length === 0) return;

                // Sort: Default (Text) first, then others
                const sorted = allPhotos.slice().sort((a, b) => {
                    if (a.isDefault) return -1;
                    if (b.isDefault) return 1;
                    return 0; // Keep original order for uploads
                });

                let nextIndex = 0;
                if (STATE.targetPhoto) {
                    const currentIndex = sorted.indexOf(STATE.targetPhoto);
                    if (currentIndex !== -1) {
                        nextIndex = (currentIndex + 1) % sorted.length;
                    }
                }

                STATE.targetPhoto = sorted[nextIndex];

                if (STATE.targetPhoto) {
                    STATE.mode = 'FOCUS';
                }
            }

            initEvents() {
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }



            generateTextPositions(text) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 500;
                canvas.height = 100;

                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 80px "Cinzel", serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const positions = [];

                // Sample pixels
                // Increase stride to reduce particle count (Sparse sampling)
                for (let y = 0; y < canvas.height; y += 4) {
                    for (let x = 0; x < canvas.width; x += 4) {
                        const index = (y * canvas.width + x) * 4;
                        if (data[index] > 128) {
                            positions.push({
                                x: (x - canvas.width / 2) * 0.1, // Scale down to 0.1
                                y: -(y - canvas.height / 2) * 0.1 - 17, // Adjusted to -17 as requested
                                z: 0
                            });
                        }
                    }
                }
                return positions;
            }

            triggerLoveMode() {
                if (STATE.mode === 'LOVE_GALLERY' || STATE.mode === 'LOVE_HEART') return;

                console.log("ðŸ’– LOVE MODE ACTIVATED (INDEPENDENT SYSTEM) ðŸ’–");
                STATE.mode = 'LOVE_GALLERY';
                STATE.loveSeq.galleryIndex = 0;
                STATE.loveSeq.timer = Date.now();

                // 1. Hijack Photos: Move from mainGroup to Scene so they persist when mainGroup is hidden
                const photos = this.particles.filter(p => p.type === 'PHOTO');
                STATE.loveSeq.photos = photos;
                photos.forEach(p => {
                    this.scene.attach(p.mesh); // Preserves World Transform, detaches from mainGroup
                    p.mesh.scale.set(10, 10, 10); // Force scale up for gallery
                });

                // Pre-calculate Text Positions for Love Particles
                const textPositions = this.generateTextPositions("I LOVE YOU");

                // Assign Love Particles logic
                const loveDecos = this.loveParticles;
                // Increase allocation to 60% for clearer text
                const maxText = Math.floor(loveDecos.length * 0.6);

                loveDecos.forEach(p => {
                    p.loveRole = 'HEART';
                    p.loveTarget = null;
                });

                let textCount = 0;
                for (let i = 0; i < loveDecos.length; i++) {
                    if (textCount < textPositions.length && textCount < maxText) {
                        loveDecos[i].loveRole = 'TEXT';
                        loveDecos[i].loveTarget = textPositions[textCount];
                        textCount++;
                    } else {
                        loveDecos[i].loveRole = 'HEART';
                    }
                }
                console.log(`Assigned ${textCount} Love particles to Text.`);

                // Hide Tree
                this.mainGroup.visible = false;
                this.loveGroup.visible = true;
            }

            restoreTreeMode() {
                console.log("EXITING LOVE MODE -> TREE");
                STATE.mode = 'TREE';

                // Restore Photos to MainGroup
                const photos = this.particles.filter(p => p.type === 'PHOTO');
                photos.forEach(p => {
                    this.mainGroup.attach(p.mesh);
                    p.mesh.scale.set(1, 1, 1);
                });

                this.mainGroup.visible = true;
                this.loveGroup.visible = false;
            }

            // (End of Love Mode helper methods)

            async initMediaPipe() {
                try {
                    const filesetResolver = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                    );
                    this.handLandmarker = await HandLandmarker.createFromOptions(filesetResolver, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 2
                    });

                    const video = document.getElementById('webcam');
                    const canvas = document.getElementById('cv-canvas');

                    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                facingMode: 'user',
                                width: { ideal: 640 },
                                height: { ideal: 480 }
                            },
                            audio: false
                        });
                        video.srcObject = stream;
                        video.addEventListener("loadeddata", () => {
                            // Hide loader when everything is ready
                            this.hideLoader();
                            this.predictWebcam();
                        });
                    }
                } catch (e) {
                    console.error("MediaPipe Init Error:", e);
                    // Hide loader anyway so user can at least see 3D
                    this.hideLoader();
                }
            }



            predictWebcam() {
                const video = document.getElementById('webcam');
                // Limit prediction rate if needed, but per frame is fine for simple logic
                if (this.handLandmarker && video.videoWidth > 0) {
                    const nowInMs = Date.now();
                    const results = this.handLandmarker.detectForVideo(video, nowInMs);

                    if (results.landmarks && results.landmarks.length > 0) {
                        this.processGestures(results.landmarks);
                    }
                }
                requestAnimationFrame(this.predictWebcam.bind(this));
            }

            hideLoader() {
                const loader = document.getElementById('loader');

                if (loader && loader.style.display !== 'none') {
                    console.log("Loader Finished -> Launching directly (User confident in Autoplay)");

                    // 1. Force Renderer Refresh (Fixes "Disappearing Particles" bug)
                    // Toggling UI ('H' key) likely triggered a resize/layout shift that fixed the composer.
                    // We force it here to ensure clean start.
                    this.onWindowResize();
                    this.mainGroup.visible = true;
                    STATE.mode = 'TREE';

                    // 2. Play Music Immediately
                    const meting = document.querySelector('meting-js');
                    if (meting && meting.aplayer) {
                        try {
                            meting.aplayer.play();
                            console.log("Attempted Autoplay.");
                        } catch (e) {
                            console.warn("Autoplay failed:", e);
                        }
                    }

                    // 3. Hide Loader
                    loader.style.opacity = 0;
                    setTimeout(() => loader.style.display = 'none', 800);
                }
            }

            processGestures(allLandmarks) {
                // Safety: Ensure we have at least one hand
                if (!allLandmarks || allLandmarks.length === 0) return;

                // Use the first hand for standard interaction
                const landmarks = allLandmarks[0];

                // Helper for distance (Single Hand)
                const dist = (i, j) => Math.hypot(landmarks[i].x - landmarks[j].x, landmarks[i].y - landmarks[j].y);
                const dIndex = dist(8, 0), dMiddle = dist(12, 0), dRing = dist(16, 0), dPinky = dist(20, 0);



                // --- LOVE MODE LOGIC ---
                // 1. Lock: Gallery Mode -> NO INTERACTION
                if (STATE.mode === 'LOVE_GALLERY') return;

                // 2. Exit: Heart Mode -> Check for Exit Gesture
                if (STATE.mode === 'LOVE_HEART') {
                    // A. STRICT TIME LOCK (Animation Loop)
                    // Requirements: "Cannot accept any gesture until animation runs out"
                    // We set a fixed duration of 8 seconds for the "Show".
                    if (!STATE.lastHeartModeStart || (Date.now() - STATE.lastHeartModeStart < 8000)) return;

                    // B. Hold Lock: If still holding Two-Hand Heart, DO NOT EXIT
                    // (Prevents accidental exit if user holds gesture too long)
                    if (allLandmarks.length >= 2) {
                        const hA = allLandmarks[0];
                        const hB = allLandmarks[1];
                        const distH = (i, j) => Math.hypot(hA[i].x - hB[j].x, hA[i].y - hB[j].y);
                        const sA = Math.hypot(hA[0].x - hA[9].x, hA[0].y - hA[9].y);
                        const sB = Math.hypot(hB[0].x - hB[9].x, hB[0].y - hB[9].y);
                        const rS = (sA + sB) / 2;
                        // Check raw shape of Heart
                        if (distH(8, 8) < rS * 0.8 && distH(4, 4) < rS * 0.8) return;
                    }

                    const avgSpread = (dIndex + dMiddle + dRing + dPinky) / 4;
                    const isPalmOpen = avgSpread > CONFIG.gestures.palmOpenThreshold;
                    const isFist = avgSpread < 0.04;

                    if (isPalmOpen || isFist) this.restoreTreeMode();
                    return;
                }

                // --- TWO-HAND HEART LOGIC (Trigger) ---
                if (allLandmarks.length >= 2) {
                    const handA = allLandmarks[0];
                    const handB = allLandmarks[1];

                    // Helper for distance between hands
                    const distHands = (idxA, idxB) => Math.hypot(handA[idxA].x - handB[idxB].x, handA[idxA].y - handB[idxB].y);

                    // Ref Scale: Avg Hand Size
                    const sizeA = Math.hypot(handA[0].x - handA[9].x, handA[0].y - handA[9].y);
                    const sizeB = Math.hypot(handB[0].x - handB[9].x, handB[0].y - handB[9].y);
                    const refSize = (sizeA + sizeB) / 2;

                    // Heart Shape Criteria
                    // 1. Index Tips & 2. Thumb Tips Touching
                    const indexTouch = distHands(8, 8) < (refSize * 0.5);
                    const thumbTouch = distHands(4, 4) < (refSize * 0.5);

                    if (indexTouch && thumbTouch) {
                        // Strict Debounce: Trigger only once until released
                        if (!STATE.isHeartDebounce) {
                            console.log("Two-Hand Heart Detected! ðŸ«¶");
                            this.triggerLoveMode();
                            STATE.isHeartDebounce = true;
                            // STATE.lastHeartTime = Date.now(); // No longer needed for logic, but keeps state clean
                        }
                    } else {
                        STATE.isHeartDebounce = false;
                    }
                }

                // --- STANDARD TREE MODE GESTURES ---
                // Robust Logic with Sequential Pinch Selection
                // Landmarks: 0: Wrist, 4: ThumbTip, 8: IndexTip, 12: MiddleTip, 16: RingTip, 20: PinkyTip, 9: MiddleMCP

                // (Variables declared at top of function)

                // --- Classification ---

                // 1. OK Gesture (Pinch + Middle Extended)
                // Logic: Pinch < 0.05, Middle Extended. 
                // We use Edge Triggering (Debounce) to cycle photos.
                const isPinch = dist(4, 8) < 0.05 && dMiddle > 0.15 && dMiddle > dIndex * 1.2;

                if (isPinch) {
                    // Logic: Must be a NEW pinch (not holding) and some time passed
                    // Using isPinching flag as state
                    if (!STATE.isPinching && (Date.now() - (STATE.lastPinchTime || 0) > 500)) {
                        // Rising Edge: Trigger Action
                        this.pickNextTarget();
                        STATE.isPinching = true;
                        STATE.lastPinchTime = Date.now();
                    }
                    return; // Lock other gestures while pinching
                } else {
                    STATE.isPinching = false; // Reset when released
                }

                // --- 2. Pointing (Spatial Selection) ---
                const isPointing = dIndex > 0.1 && dMiddle < dIndex * 0.7 && dRing < dIndex * 0.7;

                if (isPointing) {
                    STATE.mode = 'FOCUS';
                    STATE.forceTextTarget = false;
                    STATE.hasPalmCenter = false;
                    STATE.spinVel.x *= 0.9; STATE.spinVel.y *= 0.9;

                    if (STATE.potentialTarget) {
                        STATE.targetPhoto = STATE.potentialTarget;
                    }
                }
                else {
                    // --- Standard Mode Control (Scatter vs Tree) ---
                    // Calculate avgSpread first (Used for Palm Open / Scatter)
                    const avgSpread = (dIndex + dMiddle + dRing + dPinky) / 4;
                    const isPalmOpen = (avgSpread > CONFIG.gestures.palmOpenThreshold);

                    // 'isLove' removed (Feature Deprecated) -> Set to false for compatibility
                    const isLove = false;

                    // --- Standard Mode Control (Scatter vs Tree) ---
                    // Priority: If Love Gesture detected, stay in current mode (or maybe just Tree?)
                    // To avoid flicker, we prioritize standard modes but sequence runs in background

                    if (isLove) {
                        // Do nothing, just hold state
                    }
                    else if (isPalmOpen) {
                        // SCATTER with Dynamic Spread
                        if (STATE.mode !== 'SCATTER' || !STATE.hasPalmCenter) {
                            STATE.palmCenter = { x: landmarks[9].x, y: landmarks[9].y };
                            STATE.hasPalmCenter = true;
                            STATE.gestureBaseSpread = avgSpread;
                            STATE.scatterScale = 1.0;
                        }
                        STATE.mode = 'SCATTER';
                        STATE.forceTextTarget = false;

                        // Analog Control
                        if (STATE.gestureBaseSpread) {
                            const targetScale = THREE.MathUtils.clamp(Math.pow(avgSpread / STATE.gestureBaseSpread, 1.5), 0.5, 3.0);
                            STATE.scatterScale += (targetScale - STATE.scatterScale) * 0.1;
                        }

                        // Spin Control
                        const gain = CONFIG.gestures.sensitivity;
                        const dx = landmarks[9].x - STATE.palmCenter.x;
                        const dy = landmarks[9].y - STATE.palmCenter.y;
                        STATE.spinVel.x += (THREE.MathUtils.clamp(-dy * gain, -3, 3) - STATE.spinVel.x) * 0.2;
                        STATE.spinVel.y += (THREE.MathUtils.clamp(dx * gain, -3, 3) - STATE.spinVel.y) * 0.2;

                    } else {
                        // 4. Fist / Relaxed -> TREE
                        // Only go to tree if NOT triggering love mode
                        if (STATE.mode !== 'LOVE_GALLERY' && STATE.mode !== 'LOVE_HEART') {
                            STATE.mode = 'TREE';
                            STATE.forceTextTarget = false;
                            STATE.hasPalmCenter = false;
                            STATE.scatterScale = 1.0;
                            STATE.spinVel.x *= 0.9; STATE.spinVel.y *= 0.9;
                        }
                    }
                }
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                STATE.time += 0.01;

                this.controls.update();

                const isLoveMode = (STATE.mode === 'LOVE_GALLERY' || STATE.mode === 'LOVE_HEART');

                if (isLoveMode) {
                    // ====== LOVE MODE LOOP ======

                    // A. Animated Dust (Snow)
                    const positions = this.loveDust.geometry.attributes.position.array;
                    for (let i = 0; i < 4000; i++) {
                        let y = positions[i * 3 + 1];
                        y += this.dustData[i].vy;
                        if (y < -100) y = 100; // Reset to top
                        positions[i * 3 + 1] = y;
                        // Slight sway
                        positions[i * 3] += Math.sin(STATE.time + i) * 0.02;
                    }
                    this.loveDust.geometry.attributes.position.needsUpdate = true;

                    // B. Main Love Particles Update
                    const total = this.loveParticles.length;
                    this.loveParticles.forEach((p, idx) => {
                        let targetPos = new THREE.Vector3();
                        let targetRot = new THREE.Euler(0, 0, 0);
                        let targetScale = p.targetScale.set(1, 1, 1);

                        if (STATE.mode === 'LOVE_GALLERY') {
                            // Starry Background
                            const r = p.sphere.r;
                            const phi = p.sphere.phi;
                            const theta = p.sphere.theta;

                            targetPos.setFromSphericalCoords(r, phi, theta);
                            // Rotate slow background
                            targetPos.applyAxisAngle(new THREE.Vector3(0, 1, 0), STATE.time * 0.1);

                            targetRot.set(STATE.time + idx, STATE.time, 0);

                        } else if (STATE.mode === 'LOVE_HEART') {
                            if (p.loveRole === 'TEXT') {
                                // Form "I LOVE YOU"
                                const pt = p.loveTarget;
                                if (pt) {
                                    targetPos.set(pt.x, pt.y, pt.z);
                                    targetScale.set(0.5, 0.5, 0.5);
                                }
                            } else {
                                // Form HEART (Hollow & Scaled Up)
                                let t = (idx / total) * Math.PI * 2;
                                t = (t + p.randomOffset * Math.PI) % (Math.PI * 2);

                                // Reverted to Hollow as requested, increased scale
                                const scale = 0.9;

                                const x = 16 * Math.pow(Math.sin(t), 3);
                                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                                const z = (p.randomOffset - 0.5) * 5;

                                targetPos.set(x * scale, y * scale + 4, z * scale); // Shift Y (+4)

                                targetRot.set(STATE.time, STATE.time, 0);
                            }
                        }

                        // Lerp Main Love Particles
                        p.mesh.position.lerp(targetPos, 0.05);
                        p.mesh.rotation.x = THREE.MathUtils.lerp(p.mesh.rotation.x, targetRot.x, 0.1);
                        p.mesh.rotation.y = THREE.MathUtils.lerp(p.mesh.rotation.y, targetRot.y, 0.1);
                        p.mesh.rotation.z = THREE.MathUtils.lerp(p.mesh.rotation.z, targetRot.z, 0.1);
                        p.mesh.scale.lerp(targetScale, 0.1);
                    });

                    // C. Hijack Photos
                    const photos = this.particles.filter(p => p.type === 'PHOTO');
                    photos.forEach((p, idx) => {
                        let targetPos = new THREE.Vector3();
                        let targetScale = new THREE.Vector3(0, 0, 0);
                        let targetRot = new THREE.Euler(0, 0, 0);

                        if (STATE.mode === 'LOVE_GALLERY') {
                            const photos = STATE.loveSeq.photos;
                            const gIdx = STATE.loveSeq.galleryIndex;
                            const myIdx = photos.indexOf(p);

                            // "Netflix Style" Carousel
                            // Calculate distance from center (active item)
                            let diff = myIdx - gIdx;

                            // Spacing between items
                            const spacing = 35;

                            // Visible Range: Show neighbors but fade out distant ones
                            if (Math.abs(diff) <= 4) {
                                targetPos.set(diff * spacing, 0, 30 - Math.abs(diff) * 5); // Curve slightly back

                                if (diff === 0) {
                                    // Active Target: Slightly Enhanced
                                    targetScale.set(12, 12, 12); // Slightly larger than before (10)
                                    targetPos.z += 5; // Bring forward
                                } else {
                                    // Neighbors: Normal Size
                                    targetScale.set(8, 8, 8); // Visible but smaller
                                    targetPos.z -= 5; // Push back
                                }

                                // Face Camera
                                targetRot.set(0, 0, 0);
                            } else {
                                // Hide distant items
                                targetPos.set(diff * spacing, -900, 0);
                                targetScale.set(0, 0, 0);
                            }
                        } else if (STATE.mode === 'LOVE_HEART') {
                            // HIDE PHOTOS IN HEART MODE as requested
                            targetPos.set(0, -1000, 0);
                            targetScale.set(0, 0, 0);
                        }

                        p.mesh.position.lerp(targetPos, 0.1);
                        p.mesh.scale.lerp(targetScale, 0.1);
                        p.mesh.rotation.set(0, 0, 0);
                        // Ensure visibility since parent is hidden? 
                        // NO, if parent is hidden, children are hidden.
                        // We will rely on manual material override if needed or re-parenting.
                        // ACTUALLY: The Simplest fix is to add them to Scene or LoveGroup temporarily.
                        // Or, just for this logic, assume they are visible.
                        // Wait, if MainGroup is hidden, photos are hidden.
                        // FIX: We need to set mainGroup visible = true, but HIDE distinct children?
                        // NO, that's messy.
                        // BETTER: In triggerLoveMode, move photos to 'loveGroup'. In exit, move back.
                    });

                } else {
                    // ====== ORIGINAL TREE LOOP ======
                    if (STATE.mode === 'TREE') {
                        STATE.rotation.y -= 0.005;
                        STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0, 0.05);
                    } else if (STATE.mode === 'SCATTER') {
                        // Physics spin from gesture
                        STATE.rotation.y += STATE.spinVel.y * 0.016;
                        STATE.rotation.x += STATE.spinVel.x * 0.016;

                        if (!this.handLandmarker || !STATE.hasPalmCenter) {
                            STATE.spinVel.x *= 0.95; STATE.spinVel.y *= 0.95;
                        }
                    } else if (STATE.mode === 'FOCUS') {
                        STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0, 0.1);
                        STATE.rotation.y = THREE.MathUtils.lerp(STATE.rotation.y, 0, 0.1);
                    }

                    this.mainGroup.rotation.x = STATE.rotation.x;
                    this.mainGroup.rotation.y = STATE.rotation.y;

                    // Update particles
                    this.particles.forEach((p, idx) => {
                        let scaleMultiplier = 1.0;

                        // 1. Potential Target (Highest Priority - PREVIEW)
                        if (p === STATE.potentialTarget && STATE.mode !== 'FOCUS') {
                            const pulse = 1.0 + Math.sin(STATE.time * 10) * 0.5;
                            if (STATE.mode === 'SCATTER') {
                                scaleMultiplier = 2.5 + pulse * 0.1;
                            } else {
                                scaleMultiplier = 1.0 + pulse * 0.05;
                            }
                            // Glow effect
                            const highlightColor = new THREE.Color().setHSL(0.12, 1.0, 0.8);
                            for (let i = 0; i < 4; i++) {
                                if (p.mesh.material[i]) {
                                    p.mesh.material[i].color.copy(highlightColor);
                                    if (p.mesh.material[i].emissive) {
                                        p.mesh.material[i].emissive.setHex(0x888800);
                                        p.mesh.material[i].emissiveIntensity = 2.0;
                                    }
                                }
                            }
                            if (p.mesh.material[4] && p.mesh.material[4].emissive) {
                                p.mesh.material[4].emissive = new THREE.Color(0x222222);
                                p.mesh.material[4].emissiveIntensity = 0.2;
                            }
                        }
                        // 2. Target Photo (Already Selected)
                        else if (p === STATE.targetPhoto) {
                            scaleMultiplier = 1.2;
                            if (STATE.mode !== 'FOCUS') {
                                if (p.mesh.material[4] && p.mesh.material[4].emissive) {
                                    p.mesh.material[4].emissive = new THREE.Color(0xffaa00);
                                    p.mesh.material[4].emissiveIntensity = 0.5;
                                }
                            } else {
                                if (p.mesh.material[4] && p.mesh.material[4].emissive) {
                                    p.mesh.material[4].emissive = new THREE.Color(0x000000);
                                    p.mesh.material[4].emissiveIntensity = 0.0;
                                }
                            }
                            // Reset frame coloring
                            for (let i = 0; i < 4; i++) {
                                if (p.mesh.material[i]) {
                                    p.mesh.material[i].color.setHex(CONFIG.colors.gold);
                                    p.mesh.material[i].emissive.setHex(0x221100);
                                    p.mesh.material[i].emissiveIntensity = 0.5;
                                }
                            }
                        }
                        // 3. Normal State
                        else {
                            p.resetMaterial();
                        }

                        p.update(idx, this.particles.length, scaleMultiplier);
                    });
                }

                this.updatePotentialTarget();

                // Love Mode Logic
                if (STATE.mode === 'LOVE_GALLERY') {
                    const elapsed = Date.now() - STATE.loveSeq.timer;
                    const durationPerPhoto = 2000; // 2 Seconds per Slide

                    if (elapsed > durationPerPhoto) {
                        STATE.loveSeq.galleryIndex++;
                        STATE.loveSeq.timer = Date.now();

                        if (STATE.loveSeq.galleryIndex >= STATE.loveSeq.photos.length) {
                            STATE.mode = 'LOVE_HEART';
                            STATE.lastHeartModeStart = Date.now();
                        }
                    }
                }

                this.composer.render();
            }

            // Renamed/Refactored from updateClosestTarget
            updatePotentialTarget() {
                // LOCK SELECTION: Do not update potential target if we are already focusing!
                if (STATE.mode === 'FOCUS') return;

                const photos = this.particles.filter(p => p.type === 'PHOTO');
                if (photos.length === 0) return;

                let closestDist = Infinity;
                let closestPhoto = null;
                const worldPos = new THREE.Vector3();

                // Find the photo physically closest to the camera
                photos.forEach(p => {
                    worldPos.copy(p.mesh.position).applyMatrix4(this.mainGroup.matrixWorld);
                    const dist = worldPos.distanceTo(this.camera.position);

                    if (dist < closestDist) {
                        closestDist = dist;
                        closestPhoto = p;
                    }
                });

                if (closestPhoto) {
                    STATE.potentialTarget = closestPhoto;
                }
            }
        }

        // --- Particle Class ---
        class Particle {
            constructor(mesh, type = 'DECO') {
                this.mesh = mesh;
                this.type = type; // 'DECO' or 'PHOTO'
                this.randomOffset = Math.random() * 100;
                this.randomSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05
                );

                // Pre-calculate tree position factor
                // 0 to 1, but for photos we want them distributed, not clamped to end
                this.treeT = Math.random();

                // Floating Animation State
                this.wanderPhase = Math.random() * Math.PI * 2;
                this.wanderSpeed = 0.5 + Math.random() * 0.5;
            }

            update(idx, total, scaleMultiplier = 1.0) {
                let targetPos = new THREE.Vector3();
                let targetRot = new THREE.Euler(0, 0, 0);
                // Default scale
                let targetScale = new THREE.Vector3(1, 1, 1);
                // Use stored treeT for decoration too if we want random mix, 
                // but let's keep decoration structured by index for the spiral look, 
                // and only randomize photos/special items or just use this.treeT for all for a more organic tree.
                // Let's use idx/total for DECO to keep the spiral shape clean, but randomized T for PHOTOS.

                const t = (this.type === 'PHOTO') ? this.treeT : (idx / total);

                if (STATE.mode === 'TREE') {
                    // Spiral Cone
                    const h = (t * 22) - 10;
                    const progress = (h + 10) / 22;

                    // For photos, push them slightly out so they are visible on surface
                    const rOffset = (this.type === 'PHOTO') ? 1.5 : 0;
                    const r = (11 * (1 - progress)) + rOffset;

                    const angle = t * 50 * Math.PI;

                    targetPos.set(Math.cos(angle) * r, h, Math.sin(angle) * r);
                    targetRot.set(0, -angle, 0);

                } else if (STATE.mode === 'SCATTER') {
                    // Random distribution for Photos, structured for Decorations
                    let phi, theta, r;

                    if (this.type === 'PHOTO') {
                        // RANDOM SCATTER
                        // Use unique random values for each photo
                        const seed1 = (this.treeT * 123.45) % 1;
                        const seed2 = (this.randomOffset * 67.89) % 1;

                        // Base spherical coordinates
                        let basePhi = Math.acos(-1 + (2 * seed1));
                        let baseTheta = Math.sqrt(Math.PI * 100) * seed2;

                        // Add Gentle Wandering (Floating inside sphere)
                        // Use STATE.time to animate
                        phi = basePhi + Math.sin(STATE.time * this.wanderSpeed + this.wanderPhase) * 0.2;
                        theta = baseTheta + Math.cos(STATE.time * this.wanderSpeed + this.wanderPhase) * 0.2;

                        // Constrained Radius: 12 to 20 (Closer to tree, inside "sphere")
                        r = 12 + (this.treeT * 8);

                        targetPos.setFromSphericalCoords(r, phi, theta);
                        // Apply Scatter Scale (Gesture expansion)
                        targetPos.multiplyScalar(STATE.scatterScale);

                        // Scale up photos
                        targetScale.set(5, 5, 5);

                    } else {
                        // DECORATIONS (Keep Sphere shape)
                        phi = Math.acos(-1 + (2 * idx) / total);
                        theta = Math.sqrt(total * Math.PI) * phi;
                        r = 15 + Math.sin(idx) * 5;

                        targetPos.setFromSphericalCoords(r, phi, theta);
                        targetPos.multiplyScalar(STATE.scatterScale);
                    }

                    // Rotation
                    this.mesh.rotation.x += this.randomSpeed.x;
                    this.mesh.rotation.y += this.randomSpeed.y;

                } else if (STATE.mode === 'FOCUS') {
                    if (this === STATE.targetPhoto) {
                        // Center front
                        // Specs: Pos(0, 2, 35), Scale 8.0 (adjusted for base 0.6) = 4.8 size
                        targetPos.set(0, 2, 35);
                        targetScale.set(8, 8, 8);
                        // Face camera
                        targetRot.set(0, 0, 0);
                    } else {
                        // Background scatter
                        const phi = Math.acos(-1 + (2 * idx) / total);
                        const theta = Math.sqrt(total * Math.PI) * phi;
                        const r = 30; // Further away
                        targetPos.setFromSphericalCoords(r, phi, theta);
                        // Add some movement
                        targetPos.y += Math.sin(STATE.time + idx) * 2;
                    }
                }


                // Apply Lerp
                if (STATE.mode !== 'SCATTER') {
                    // In scatter we handle rotation manually
                    this.mesh.rotation.x += (targetRot.x - this.mesh.rotation.x) * 0.05;
                    this.mesh.rotation.y += (targetRot.y - this.mesh.rotation.y) * 0.05;
                    this.mesh.rotation.z += (targetRot.z - this.mesh.rotation.z) * 0.05;
                }

                this.mesh.position.lerp(targetPos, 0.05);

                // Apply Scale Multiplier (Relative Scaling)
                targetScale.multiplyScalar(scaleMultiplier);

                this.mesh.scale.lerp(targetScale, 0.05);
            }

            resetMaterial() {
                // Safely reset materials logic
                if (this.type === 'PHOTO') {
                    if (Array.isArray(this.mesh.material)) {
                        // Reset Photo Frame (Gold)
                        for (let i = 0; i < 4; i++) {
                            if (this.mesh.material[i]) {
                                this.mesh.material[i].color.setHex(0xd4af37); // Gold
                                this.mesh.material[i].emissive.setHex(0x000000);
                                this.mesh.material[i].emissiveIntensity = 0;
                            }
                        }
                        // Reset Photo Face (Index 4 & 5 share the same material usually)
                        // Use 0xdddddd (Grey) to prevent bloom
                        if (this.mesh.material[4]) {
                            this.mesh.material[4].color.setHex(0xdddddd);
                            if (this.mesh.material[4].emissive) {
                                this.mesh.material[4].emissive.setHex(0x000000);
                                this.mesh.material[4].emissiveIntensity = 0;
                            }
                        }
                        // Also check index 5 just in case
                        if (this.mesh.material[5]) {
                            this.mesh.material[5].color.setHex(0xdddddd);
                            if (this.mesh.material[5].emissive) {
                                this.mesh.material[5].emissive.setHex(0x000000);
                            }
                        }
                    }
                } else {
                    // For shared materials (Decorations), we avoid modifying them per-instance 
                    // to prevent flashing the whole tree.
                    // If we did clone materials, we would reset them here.
                }
            }
        }

        // Start
        new App();

    </script>
</body>

</html>
